"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const axios_1 = require("axios");
const errors_1 = require("./errors");
class Client {
    constructor(options) {
        this.abandonTransaction = (txid) => this.makeCall('abandonTransaction', txid);
        this.abortRescan = () => this.makeCall('abortRescan');
        this.addMultiSigAddress = (nrequired, keys, label = '', address_type) => this.makeCall('addMultiSigAddress', nrequired, keys, label, address_type);
        this.addNode = (node, command) => this.makeCall('addNode', node, command);
        this.backupWallet = (destination) => this.makeCall('backupWallet', destination);
        this.bumpFee = (txid, options) => this.makeCall('bumpFee', txid, options);
        this.clearBanned = () => this.makeCall('clearBanned');
        this.combineRawTransaction = (txs) => this.makeCall('combineRawTransaction', txs);
        this.createMultiSig = (nrequired, keys) => this.makeCall('createMultiSig', nrequired, keys);
        this.createRawTransaction = (inputs, outputs, locktime, replaceable) => this.makeCall('createRawTransaction', inputs, outputs, locktime, replaceable);
        this.createWallet = (name, disablePrivateKeys = false, blank = false, passphrase = '', avoidReuse = false) => this.makeCall('createWallet', name, disablePrivateKeys, blank, passphrase, avoidReuse);
        this.decodeRawTransaction = (hexstring) => this.makeCall('decodeRawTransaction', hexstring);
        this.decodeScript = (hexstring) => this.makeCall('decodeScript', hexstring);
        this.disconnectNode = (address = '', nodeid) => this.makeCall('disconnectNode', address, nodeid);
        this.dumpPrivKey = (address) => this.makeCall('dumpPrivKey', address);
        this.dumpWallet = (filename) => this.makeCall('dumpWallet', filename);
        this.encryptWallet = (passphrase) => this.makeCall('encryptWallet', passphrase);
        this.estimateFee = (nblock) => this.makeCall('estimateFee', nblock);
        this.estimateSmartFee = (conf_target, estimate_mode) => this.makeCall('estimateSmartFee', conf_target, estimate_mode);
        this.fundRawTransaction = (hexstring, options) => this.makeCall('fundRawTransaction', hexstring, options);
        this.generateToAddress = (nblock, address, maxtries) => this.makeCall('generateToAddress', nblock, address, maxtries);
        this.getAddedNodeInfo = (node) => this.makeCall('getAddedNodeInfo', node);
        this.getAddressInfo = (address) => this.makeCall('getAddressInfo', address);
        this.getBalance = (dummy = '*', minconf = 0, include_watchonly = true, avoid_reuse) => this.makeCall('getBalance', dummy, minconf, include_watchonly, avoid_reuse);
        this.getBestBlockHash = () => this.makeCall('getBestBlockHash');
        this.getBlock = (blockhash, verbosity) => this.makeCall('getBlock', blockhash, verbosity);
        this.getBlockCount = () => this.makeCall('getBlockCount');
        this.getBlockHash = (height) => this.makeCall('getBlockHash', height);
        this.getBlockHeader = (hash, verbose) => this.makeCall('getBlockHeader', hash, verbose);
        this.getBlockchainInfo = () => this.makeCall('getBlockchainInfo');
        this.getBlockchainInformation = () => this.makeCall('getBlockchainInformation');
        this.getChainTips = () => this.makeCall('getChainTips');
        // nblocks needs to be set if blockhash is set
        this.getChainTxStats = (nblocks, blockchash) => this.makeCall('getChainTxStats', nblocks, blockchash);
        this.getConnectionCount = () => this.makeCall('getConnectionCount');
        this.getDescriptorInfo = (descriptor) => this.makeCall('getDescriptorInfo', descriptor);
        this.getDifficulty = () => this.makeCall('getDifficulty');
        this.getMemoryInfo = (mode) => this.makeCall('getMemoryInfo', mode);
        this.getMemoryPoolContent = () => this.makeCall('getMemoryPoolContent');
        this.getMemoryPoolInformation = () => this.makeCall('getMemoryPoolInformation');
        this.getMempoolAncestors = (txid, verbose) => this.makeCall('getMempoolAncestors', txid, verbose);
        this.getMempoolDescendants = (txid, verbose) => this.makeCall('getMempoolDescendants', txid, verbose);
        this.getMempoolEntry = (txid) => this.makeCall('getMempoolEntry', txid);
        this.getMempoolInfo = () => this.makeCall('getMempoolInfo');
        this.getMiningInfo = () => this.makeCall('getMiningInfo');
        this.getNetTotals = () => this.makeCall('getNetTotals');
        this.getNetworkHashPs = (nblocks = '120', height) => this.makeCall('getNetworkHashPs', nblocks, height);
        this.getNetworkInfo = () => this.makeCall('getNetworkInfo');
        this.getNewAddress = (label = '', addressType) => this.makeCall('getNewAddress', label, addressType);
        this.getPeerInfo = () => this.makeCall('getPeerInfo');
        this.getRawChangeAddress = () => this.makeCall('getRawChangeAddress');
        this.getRawMempool = (verbose) => this.makeCall('getRawMempool', verbose);
        this.getRawTransaction = (txid, verbose) => this.makeCall('getRawTransaction', txid, verbose);
        this.getReceivedByAddress = (address, minconf) => this.makeCall('getReceivedByAddress', address, minconf);
        this.getTransaction = (txid, include_watchonly, verbose) => this.makeCall('getTransaction', txid, include_watchonly, verbose);
        this.getTxOut = (txid, index, include_mempool) => this.makeCall('getTxOut', txid, index, include_mempool);
        this.getTxOutProof = (txids, blockhash) => this.makeCall('getTxOutProof', txids, blockhash);
        this.getTxOutSetInfo = () => this.makeCall('getTxOutSetInfo');
        this.getUnconfirmedBalance = () => this.makeCall('getUnconfirmedBalance');
        this.getWalletInfo = () => this.makeCall('getWalletInfo');
        this.importAddress = (address, label = '', rescan = true, p2sh) => this.makeCall('importAddress', address, label, rescan, p2sh);
        this.importMulti = (requests, options) => this.makeCall('importMulti', requests, options);
        this.importPrivKey = (bitcoinprivkey, label = '', rescan) => this.makeCall('importPrivKey', bitcoinprivkey, label, rescan);
        this.importPrunedFunds = (rawtransaction, txoutproof) => this.makeCall('importPrunedFunds', rawtransaction, txoutproof);
        this.importPubKey = (pubkey, label = '', rescan) => this.makeCall('importPubKey', pubkey, label, rescan);
        this.importWallet = (filename) => this.makeCall('importWallet', filename);
        this.keypoolRefill = (newsize) => this.makeCall('keypoolRefill', newsize);
        this.listAddressGroupings = () => this.makeCall('listAddressGroupings');
        this.listBanned = () => this.makeCall('listBanned');
        this.listLockUnspent = () => this.makeCall('listLockUnspent');
        this.listReceivedByLabel = (minconf = 1, include_empty = false, include_watchonly) => this.makeCall('listReceivedByLabel', minconf, include_empty, include_watchonly);
        this.listReceivedByAddress = (minconf = 1, include_empty = false, include_watchonly, address_filter) => this.makeCall('listReceivedByAddress', minconf, include_empty, include_watchonly, address_filter);
        this.listSinceBlock = (blockhash = '', target_confirmations = 1, include_watchonly = false, include_removed) => this.makeCall('listSinceBlock', blockhash, target_confirmations, include_watchonly, include_removed);
        this.listTransactions = (label = '*', count = 10, skip = 0, include_watchonly) => this.makeCall('listTransactions', label, count, skip, include_watchonly);
        this.listUnspent = (minconf = 1, maxconf = 9999999, address = [], include_unsafe = true, query_options) => this.makeCall('listUnspent', minconf, maxconf, address, include_unsafe, query_options);
        this.listWallets = () => this.makeCall('listWallets');
        this.loadWallet = (wallet) => this.makeCall('loadWallet', wallet);
        this.lockUnspent = (unlock, transactions) => this.makeCall('lockUnspent', unlock, transactions);
        this.ping = () => this.makeCall('ping');
        this.preciousBlock = (blockhash) => this.makeCall('preciousBlock', blockhash);
        this.prioritiseTransaction = (txid, dummy, fee_delta) => this.makeCall('prioritiseTransaction', txid, dummy, fee_delta);
        this.pruneBlockchain = (height) => this.makeCall('pruneBlockchain', height);
        this.removePrunedFunds = (txid) => this.makeCall('removePrunedFunds', txid);
        this.rescanBlockchain = (start_height, stop_height) => this.makeCall('rescanBlockchain', start_height, stop_height);
        this.sendMany = (dummy, amounts, minconf = 0, comment = '', subtractfeefrom = [], replaceable = false, conf_target = 10, estimate_mode) => this.makeCall('sendMany', dummy, amounts, minconf, comment, subtractfeefrom, replaceable, conf_target, estimate_mode);
        this.sendRawTransaction = (hexstring, allowhighfees) => this.makeCall('sendRawTransaction', hexstring, allowhighfees);
        this.sendToAddress = (address, amount, comment = '', comment_to = '', subtractfeefromamount = false, replaceable = false, conf_target = 10, estimate_mode = 'UNSET', avoid_reuse) => this.makeCall('sendToAddress', address, amount, comment, comment_to, subtractfeefromamount, replaceable, conf_target, estimate_mode, avoid_reuse);
        this.setBan = (subnet, command, bantime = 0, absolute) => this.makeCall('setBan', subnet, command, bantime, absolute);
        this.setNetworkActive = (state) => this.makeCall('setNetworkActive', state);
        this.setTxFee = (amount) => this.makeCall('setTxFee', amount);
        this.signMessage = (address, message) => this.makeCall('signMessage', address, message);
        this.signMessageWithPrivKey = (privkey, message) => this.makeCall('signMessageWithPrivKey', privkey, message);
        this.signRawTransactionWithWallet = (hexstring, prevtxs = [], sighashtype) => this.makeCall('signRawTransactionWithWallet', hexstring, prevtxs, sighashtype);
        this.signRawTransactionWithKey = (hexstring, privkeys = [], sighashtype) => this.makeCall('signRawTransactionWithKey', hexstring, privkeys, sighashtype);
        this.stop = () => this.makeCall('stop');
        this.submitBlock = (hexdata, dummy) => this.makeCall('submitBlock', hexdata, dummy);
        this.upTime = () => this.makeCall('upTime');
        this.validateAddress = (address) => this.makeCall('validateAddress', address);
        this.verifyChain = (checklevel = 3, nblocks) => this.makeCall('verifyChain', checklevel, nblocks);
        this.verifyMessage = (address, signature, message) => this.makeCall('verifyMessage', address, signature, message);
        this.verifyTxOutProof = (proof) => this.makeCall('verifyTxOutProof', proof);
        this.walletLock = () => this.makeCall('walletLock');
        this.walletPassphrase = (passphrase, timeout) => this.makeCall('walletPassphrase', passphrase, timeout);
        this.walletPassphraseChange = (oldpassphrase, newpassphrase) => this.makeCall('walletPassphraseChange', oldpassphrase, newpassphrase);
        this._httpClient = axios_1.default.create({ ...options });
    }
    async makeCall(call, ...params) {
        const method = call.toLowerCase();
        params = params.filter((x) => x !== undefined);
        const payload = {
            jsonrpc: '2.0',
            id: 1,
            method,
            params,
        };
        return this.post(payload);
    }
    async post(data) {
        try {
            const resp = await this._httpClient.post('', data);
            return resp.data.result;
        }
        catch (e) {
            if (e.isAxiosError) {
                const error = e;
                if (error.code === 'ECONNREFUSED') {
                    throw new errors_1.ConnectionError('Connection to the provided address could not be established.');
                }
                if (error.response) {
                    if (error.response.data && error.response.data.error) {
                        throw new errors_1.BitcoinRpcError(error.response.data.error.code, error.response.data.error.message);
                    }
                    if (error.response.status === 401) {
                        throw new errors_1.AuthError();
                    }
                }
                throw new errors_1.UnknownError(error);
            }
            throw e;
        }
    }
}
exports.Client = Client;
