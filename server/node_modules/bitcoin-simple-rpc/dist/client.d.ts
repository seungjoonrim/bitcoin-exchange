import { AddedNodeInfo, AddressGrouping, Block, BlockHeader, BumpFeeOption, ChainInfo, ChainTip, DecodedRawTransaction, FeeEstimateMode, FetchedRawTransaction, FundRawTxOptions, GetAddressInfoResult, GetDescriptorResult, ImportMultiRequest, ListSinceBlockResult, ListTransactionsResult, ListUnspentOptions, LoadWalletResult, MemoryStats, MempoolContent, MempoolInfo, MiningInfo, NetTotals, NetworkInfo, PeerInfo, PrevTxOut, Received, ReceivedByAddress, RescanBlockchainResult, ScriptDecoded, SignRawTxResult, TxInForCreateRaw, TxOutForCreateRaw, TxOutInBlock, TxStats, UnspentTxInfo, UTXOStats, ValidateAddressResult, WalletInfo, WalletTransaction } from '.';
export declare type ClientOption = {
    baseURL: string;
    auth?: {
        username: string;
        password: string;
    };
    httpAgent?: unknown;
    httpsAgent?: unknown;
};
export declare class Client {
    private readonly _httpClient;
    constructor(options: ClientOption);
    private makeCall;
    private post;
    abandonTransaction: (txid: string) => Promise<void>;
    abortRescan: () => Promise<void>;
    addMultiSigAddress: (nrequired: number, keys: string[], label?: string, address_type?: "bech32" | "legacy" | "p2sh-segwit" | undefined) => Promise<string>;
    addNode: (node: string, command: 'add' | 'remove' | 'onentry') => Promise<void>;
    backupWallet: (destination: string) => Promise<void>;
    bumpFee: (txid: string, options?: BumpFeeOption | undefined) => Promise<{
        txid: string;
        origfee: number;
        fee: number;
        psbt?: string | undefined;
        error?: string[] | undefined;
    }>;
    clearBanned: () => Promise<void>;
    combineRawTransaction: (txs: string[]) => Promise<string>;
    createMultiSig: (nrequired: number, keys: string[]) => Promise<{
        address: string;
        redeemScript: string;
    }>;
    createRawTransaction: (inputs: TxInForCreateRaw[], outputs: TxOutForCreateRaw, locktime: number, replaceable: boolean) => Promise<string>;
    createWallet: (name: string, disablePrivateKeys?: boolean, blank?: boolean, passphrase?: string, avoidReuse?: boolean) => Promise<{
        name: string;
        warning: string;
    }>;
    decodeRawTransaction: (hexstring: string) => Promise<DecodedRawTransaction>;
    decodeScript: (hexstring: string) => Promise<ScriptDecoded>;
    disconnectNode: (address?: string, nodeid?: number | undefined) => Promise<void>;
    dumpPrivKey: (address: string) => Promise<string>;
    dumpWallet: (filename: string) => Promise<{
        filename: string;
    }>;
    encryptWallet: (passphrase: string) => Promise<void>;
    estimateFee: (nblock: number) => Promise<number>;
    estimateSmartFee: (conf_target: number, estimate_mode?: "UNSET" | "ECONOMICAL" | "CONSERVATIVE" | undefined) => Promise<{
        feerate?: number;
        errors?: string[];
        blocks?: number;
    }>;
    fundRawTransaction: (hexstring: string, options: FundRawTxOptions) => Promise<{
        hex: string;
        fee: number;
        changepos: number;
    }>;
    generateToAddress: (nblock: number, address: string, maxtries?: number | undefined) => Promise<string[]>;
    getAddedNodeInfo: (node?: string | undefined) => Promise<AddedNodeInfo[]>;
    getAddressInfo: (address: string) => Promise<GetAddressInfoResult>;
    getBalance: (dummy?: string, minconf?: number, include_watchonly?: boolean, avoid_reuse?: boolean | undefined) => Promise<number>;
    getBestBlockHash: () => Promise<string>;
    getBlock: (blockhash: string, verbosity?: 0 | 2 | 1 | undefined) => Promise<string | Block>;
    getBlockCount: () => Promise<number>;
    getBlockHash: (height: number) => Promise<string>;
    getBlockHeader: (hash: string, verbose?: boolean | undefined) => Promise<string | BlockHeader>;
    getBlockchainInfo: () => Promise<ChainInfo>;
    getBlockchainInformation: () => Promise<ChainInfo>;
    getChainTips: () => Promise<ChainTip[]>;
    getChainTxStats: (nblocks?: number | undefined, blockchash?: string | undefined) => Promise<TxStats>;
    getConnectionCount: () => Promise<number>;
    getDescriptorInfo: (descriptor: string) => Promise<GetDescriptorResult>;
    getDifficulty: () => Promise<number>;
    getMemoryInfo: (mode?: "stats" | "mallocinfo" | undefined) => Promise<MemoryStats | string>;
    getMemoryPoolContent: () => Promise<MempoolContent>;
    getMemoryPoolInformation: () => Promise<MempoolInfo>;
    getMempoolAncestors: (txid: string, verbose?: boolean | undefined) => Promise<MempoolContent[] | string[] | null[]>;
    getMempoolDescendants: (txid: string, verbose?: boolean | undefined) => Promise<MempoolContent[] | string[] | null[]>;
    getMempoolEntry: (txid: string) => Promise<MempoolContent>;
    getMempoolInfo: () => Promise<MempoolInfo>;
    getMiningInfo: () => Promise<MiningInfo>;
    getNetTotals: () => Promise<NetTotals>;
    getNetworkHashPs: (nblocks?: string, height?: number | undefined) => Promise<number>;
    getNetworkInfo: () => Promise<NetworkInfo>;
    getNewAddress: (label?: string, addressType?: "bech32" | "legacy" | "p2sh-segwit" | undefined) => Promise<string>;
    getPeerInfo: () => Promise<PeerInfo[]>;
    getRawChangeAddress: () => Promise<string>;
    getRawMempool: (verbose?: boolean | undefined) => Promise<MempoolContent[] | string[] | null[]>;
    getRawTransaction: (txid: string, verbose?: boolean | undefined) => Promise<FetchedRawTransaction | string>;
    getReceivedByAddress: (address: string, minconf?: number | undefined) => Promise<number>;
    getTransaction: (txid: string, include_watchonly?: boolean | undefined, verbose?: boolean | undefined) => Promise<WalletTransaction>;
    getTxOut: (txid: string, index: number, include_mempool?: boolean | undefined) => Promise<TxOutInBlock>;
    getTxOutProof: (txids: string[], blockhash?: string | undefined) => Promise<string>;
    getTxOutSetInfo: () => Promise<UTXOStats>;
    getUnconfirmedBalance: () => Promise<number>;
    getWalletInfo: () => Promise<WalletInfo>;
    importAddress: (address: string, label?: string, rescan?: boolean, p2sh?: boolean | undefined) => Promise<void>;
    importMulti: (requests: ImportMultiRequest[], options?: {
        rescan?: boolean | undefined;
    } | undefined) => Promise<{
        success: boolean;
        error?: {
            code: string;
            message: string;
        };
    }[]>;
    importPrivKey: (bitcoinprivkey: string, label?: string, rescan?: boolean | undefined) => Promise<void>;
    importPrunedFunds: (rawtransaction: string, txoutproof: string) => Promise<void>;
    importPubKey: (pubkey: string, label?: string, rescan?: boolean | undefined) => Promise<void>;
    importWallet: (filename: string) => Promise<void>;
    keypoolRefill: (newsize?: number | undefined) => Promise<void>;
    listAddressGroupings: () => Promise<AddressGrouping[][]>;
    listBanned: () => Promise<{
        address: string;
        banned_until: number;
        ban_created: number;
        ban_reason: string;
    }>;
    listLockUnspent: () => Promise<{
        txid: string;
        vout: number;
    }[]>;
    listReceivedByLabel: (minconf?: number, include_empty?: boolean, include_watchonly?: boolean | undefined) => Promise<Received[]>;
    listReceivedByAddress: (minconf?: number, include_empty?: boolean, include_watchonly?: boolean | undefined, address_filter?: string | undefined) => Promise<ReceivedByAddress[]>;
    listSinceBlock: (blockhash?: string, target_confirmations?: number, include_watchonly?: boolean, include_removed?: boolean | undefined) => Promise<ListSinceBlockResult>;
    listTransactions: (label?: string, count?: number, skip?: number, include_watchonly?: boolean | undefined) => Promise<ListTransactionsResult[]>;
    listUnspent: (minconf?: number, maxconf?: number, address?: string[], include_unsafe?: boolean, query_options?: ListUnspentOptions | undefined) => Promise<UnspentTxInfo[]>;
    listWallets: () => Promise<string[]>;
    loadWallet: (wallet: string) => Promise<LoadWalletResult>;
    lockUnspent: (unlock: boolean, transactions?: {
        txid: string;
        vout: number;
    }[] | undefined) => Promise<boolean>;
    ping: () => Promise<void>;
    preciousBlock: (blockhash: string) => Promise<void>;
    prioritiseTransaction: (txid: string, dummy: 0, fee_delta: number) => Promise<boolean>;
    pruneBlockchain: (height: number) => Promise<number>;
    removePrunedFunds: (txid: string) => Promise<void>;
    rescanBlockchain: (start_height?: number | undefined, stop_height?: number | undefined) => Promise<RescanBlockchainResult>;
    sendMany: (dummy: '', amounts: {
        address: string;
    }, minconf?: number, comment?: string, subtractfeefrom?: string[], replaceable?: boolean, conf_target?: number, estimate_mode?: "UNSET" | "ECONOMICAL" | "CONSERVATIVE" | undefined) => Promise<string>;
    sendRawTransaction: (hexstring: string, allowhighfees?: boolean | undefined) => Promise<void>;
    sendToAddress: (address: string, amount: number, comment?: string, comment_to?: string, subtractfeefromamount?: boolean, replaceable?: boolean, conf_target?: number, estimate_mode?: FeeEstimateMode, avoid_reuse?: boolean | undefined) => Promise<string>;
    setBan: (subnet: string, command: 'add' | 'remove', bantime?: number, absolute?: boolean | undefined) => Promise<void>;
    setNetworkActive: (state: boolean) => Promise<void>;
    setTxFee: (amount: number | string) => Promise<boolean>;
    signMessage: (address: string, message: string) => Promise<string>;
    signMessageWithPrivKey: (privkey: string, message: string) => Promise<{
        signature: string;
    }>;
    signRawTransactionWithWallet: (hexstring: string, prevtxs?: PrevTxOut[], sighashtype?: "ALL" | "NONE" | "SINGLE" | "ALL|ANYONECANPAY" | "NONE|ANYONECANPAY" | "SINGLE|ANYONECANPAY" | undefined) => Promise<SignRawTxResult>;
    signRawTransactionWithKey: (hexstring: string, privkeys?: string[], sighashtype?: "ALL" | "NONE" | "SINGLE" | "ALL|ANYONECANPAY" | "NONE|ANYONECANPAY" | "SINGLE|ANYONECANPAY" | undefined) => Promise<SignRawTxResult>;
    stop: () => Promise<void>;
    submitBlock: (hexdata: string, dummy?: string | undefined) => Promise<void>;
    upTime: () => Promise<number>;
    validateAddress: (address: string) => Promise<ValidateAddressResult>;
    verifyChain: (checklevel?: number, nblocks?: number | undefined) => Promise<boolean>;
    verifyMessage: (address: string, signature: string, message: string) => Promise<boolean>;
    verifyTxOutProof: (proof: string) => Promise<string[]>;
    walletLock: () => Promise<void>;
    walletPassphrase: (passphrase: string, timeout: number) => Promise<void>;
    walletPassphraseChange: (oldpassphrase: string, newpassphrase: string) => Promise<string>;
}
